#Lua table(表)

Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。

Lua table 是不固定大小的，你可以根据自己需要进行扩容。

Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 

例如string.format表示使用"format"来索引table string。

##table(表)的构造
```lua
mytable = {}

-- 指定值

mytable[1]= "Lua"

-- 移除引用

mytable = nil

-- lua 垃圾回收会释放内存

```

当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。  

如果 a 设置为 nil ，则 b 同样能访问 table 的元素。  

如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 

```lua
-- 初始化表

-- 简单的 table

mytable = {}

print("mytable 的类型是 ",type(mytable))

mytable[1]= "Lua"

mytable["wow"] = "修改前"

print("mytable 索引为 1 的元素是 ", mytable[1])

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- alternatetable和mytable的是指同一个 table

alternatetable = mytable

print("alternatetable 索引为 1 的元素是 ", alternatetable[1])

print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])

alternatetable["wow"] = "修改后"

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- 释放变量

alternatetable = nil

print("alternatetable 是 ", alternatetable)

-- mytable 仍然可以访问

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

mytable = nil

print("mytable 是 ", mytable)

```

##table操作
1.连接

table.concat (table [, sep [, start [, end]]]):  

concat是concatenate(连锁, 连接)的缩写.  

 table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。
返回的是字符串

2.插入和移除

```lua
fruits = {"banana","orange","apple"};

-- 在末尾插入

table.insert(fruits,"mango");

print("索引为 4 的元素为 ",fruits[4]);

-- 在索引为 2 的键处插入

table.insert(fruits,2,"grapes")

print("索引为 2 的元素为 ",fruits[2])

print("最后一个元素为 ",fruits[5])

table.remove(fruits)

print("移除后最后一个元素为 ",fruits[5])

```
3.排序  
```lua
fruits = {"banana","orange","apple","grapes"}

print("排序前")

for k,v in ipairs(fruits) do

 print(k,v)

end

table.sort(fruits)

print("排序后")

for k,v in ipairs(fruits) do

 print(k,v)

end


```
