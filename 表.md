#Lua table(表)

Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。

Lua table 是不固定大小的，你可以根据自己需要进行扩容。

Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 

例如string.format表示使用"format"来索引table string。

##table(表)的构造
```lua
mytable = {}

-- 指定值

mytable[1]= "Lua"

-- 移除引用

mytable = nil

-- lua 垃圾回收会释放内存

```

当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。  

如果 a 设置为 nil ，则 b 同样能访问 table 的元素。  

如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 

```lua
-- 初始化表

-- 简单的 table

mytable = {}

print("mytable 的类型是 ",type(mytable))

mytable[1]= "Lua"

mytable["wow"] = "修改前"

print("mytable 索引为 1 的元素是 ", mytable[1])

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- alternatetable和mytable的是指同一个 table

alternatetable = mytable

print("alternatetable 索引为 1 的元素是 ", alternatetable[1])

print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])

alternatetable["wow"] = "修改后"

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- 释放变量

alternatetable = nil

print("alternatetable 是 ", alternatetable)

-- mytable 仍然可以访问

print("mytable 索引为 wow 的元素是 ", mytable["wow"])

mytable = nil

print("mytable 是 ", mytable)

```

##table操作
1.table.concat (table [, sep [, start [, end]]]):
concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。

